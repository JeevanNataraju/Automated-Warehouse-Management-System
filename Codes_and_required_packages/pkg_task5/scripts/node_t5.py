#! /usr/bin/env python

import os
import math
import sys
import copy
import threading
import json

import time
from time import gmtime, strftime
from datetime import date, datetime, timedelta

import rospy
import moveit_commander
import moveit_msgs.msg
import geometry_msgs.msg
import actionlib
import rospkg
import yaml

import tf2_ros
import tf2_msgs.msg
from tf.transformations import euler_from_quaternion, quaternion_from_euler

import numpy as np
from std_msgs.msg import String
from sensor_msgs.msg import Image
from cv_bridge import CvBridge, CvBridgeError

from pyzbar.pyzbar import decode

from std_srvs.srv import Empty

import requests

# Message Class used by ROS Actions internally
from pkg_ros_iot_bridge.msg import msgRosIotAction
# Message Class used for Goal Messages
from pkg_ros_iot_bridge.msg import msgRosIotGoal
from pkg_ros_iot_bridge.msg import msgRosIotResult
from pkg_ros_iot_bridge.msg import msgMqttSub

from pkg_vb_sim.srv import vacuumGripper
from pkg_vb_sim.srv import ConveyorBeltControl
from pkg_vb_sim.srv import conveyorBeltPowerMsg
from pkg_vb_sim.msg import LogicalCameraImage

import cv2


class IotRosBridgeActionClient:
    '''This class is responsible for using the node as an action client'''

    # Constructor
    def __init__(self):
        '''Constructor function of class IotRosBridgeActionClient'''

        # Initialize Action Client
        self._ac = actionlib.ActionClient('/action_ros_iot', msgRosIotAction)
        # Dictionary to Store all the goal handels
        self._goal_handles = {}

        # Store the MQTT Topic on which to Publish in a variable
        param_config_iot = rospy.get_param('config_iot')
        self._config_mqtt_sub_topic = param_config_iot['mqtt']['topic_sub']
        self._config_mqtt_pub_topic = param_config_iot['mqtt']['topic_pub']
        self._config_MQTT = param_config_iot['mqtt']['sub_cb_ros_topic']
        # Wait for Action Server that will use the action
        # - '/action_iot_ros' to start
        self._ac.wait_for_server()
        rospy.loginfo("Action server up, we can send goals.")

    # This function will be called when there is a change of state in
    # the Action Client State Machine
    def on_transition(self, goal_handle):
        '''This function will be called when there is a change of state in the Action Client State Machine'''

        # from on_goal() to on_transition(). goal_handle
        # generated by send_goal() is used here.

        result = msgRosIotResult()

        index = 0
        for i in self._goal_handles:
            if self._goal_handles[i] == goal_handle:
                index = i
                break

        rospy.loginfo("Transition Callback. Client Goal Handle #: " + str(index))
        rospy.loginfo("Comm. State: " + str(goal_handle.get_comm_state()))
        rospy.loginfo("Goal Status: " + str(goal_handle.get_goal_status()))

        # Comm State - Monitors the State Machine of the Client
        # which is different from Server's
        # Comm State = 2 -> Active
        # Comm State = 3 -> Wating for Result
        # Comm State = 7 -> Done

        # if (Comm State == ACTIVE)
        if goal_handle.get_comm_state() == 2:
            rospy.loginfo(str(index) + ": Goal just went active.")

        # if (Comm State == DONE)
        if goal_handle.get_comm_state() == 7:
            rospy.loginfo(str(index) + ": Goal is DONE")
            rospy.loginfo(goal_handle.get_terminal_state())

            # get_result() gets the result produced by the Action Server
            result = goal_handle.get_result()
            rospy.loginfo(result.flag_success)

            if result.flag_success is True:
                rospy.loginfo("Goal successfully completed. Client Goal Handle #: " + str(index))
            else:
                rospy.loginfo("Goal failed. Client Goal Handle #: " + str(index))

    # This function is used to send Goals to Action Server
    def send_goal(self, arg_protocol, arg_mode, arg_topic, arg_message):
        '''This function is used to send Goals to Action Server'''

        # Create a Goal Message object
        goal = msgRosIotGoal()

        goal.protocol = arg_protocol
        goal.mode = arg_mode
        goal.topic = arg_topic
        goal.message = arg_message

        rospy.loginfo("Send goal.")

        # self.on_transition - It is a function pointer to a function
        # which will be called when there is a change of state
        # in the Action Client State Machine
        goal_handle = self._ac.send_goal(goal,
                                         self.on_transition,
                                         None)

        return goal_handle


class Camera1:
    '''This class performs image processing tasks'''

    def __init__(self):
        '''Constructor of class Camera1'''

        self.bridge = CvBridge()
        self.image_sub = rospy.Subscriber("/eyrc/vb/camera_1/image_raw",
                                          Image, self.callback)
        self.dictorder = {}
        self.len_lst = 0
        print "Camera1 initialized"

    # Qr Code decode function
    def get_qr_data(self, arg_image):
        '''Decodes the qr code'''

        qr_result = decode(arg_image)
        self.len_lst = len(qr_result)
        color_dict = {}

        if self.len_lst == 12:
            print "DETECTED 12 PACKAGES IN node_t5"

            for i in range(self.len_lst):
                if ((qr_result[i].rect[0] >= 110 and qr_result[i].rect[0] <= 150) and (qr_result[i].rect[1] >= 290 and qr_result[i].rect[1] <= 340)):
                    color_dict["packagen00"] = qr_result[i].data
                elif ((qr_result[i].rect[0] >= 300 and qr_result[i].rect[0] <= 330) and (qr_result[i].rect[1] >= 290 and qr_result[i].rect[1] <= 340)):
                    color_dict["packagen01"] = qr_result[i].data
                elif ((qr_result[i].rect[0] >= 490 and qr_result[i].rect[0] <= 520) and (qr_result[i].rect[1] >= 290 and qr_result[i].rect[1] <= 340)):
                    color_dict["packagen02"] = qr_result[i].data
                elif ((qr_result[i].rect[0] >= 110 and qr_result[i].rect[0] <= 150) and (qr_result[i].rect[1] >= 480 and qr_result[i].rect[1] <= 520)):
                    color_dict["packagen10"] = qr_result[i].data
                elif ((qr_result[i].rect[0] >= 300 and qr_result[i].rect[0] <= 330) and (qr_result[i].rect[1] >= 480 and qr_result[i].rect[1] <= 520)):
                    color_dict["packagen11"] = qr_result[i].data
                elif ((qr_result[i].rect[0] >= 490 and qr_result[i].rect[0] <= 520) and (qr_result[i].rect[1] >= 480 and qr_result[i].rect[1] <= 520)):
                    color_dict["packagen12"] = qr_result[i].data
                elif ((qr_result[i].rect[0] >= 110 and qr_result[i].rect[0] <= 150) and (qr_result[i].rect[1] >= 630 and qr_result[i].rect[1] <= 660)):
                    color_dict["packagen20"] = qr_result[i].data
                elif ((qr_result[i].rect[0] >= 300 and qr_result[i].rect[0] <= 330) and (qr_result[i].rect[1] >= 630 and qr_result[i].rect[1] <= 660)):
                    color_dict["packagen21"] = qr_result[i].data
                elif ((qr_result[i].rect[0] >= 490 and qr_result[i].rect[0] <= 520) and (qr_result[i].rect[1] >= 630 and qr_result[i].rect[1] <= 660)):
                    color_dict["packagen22"] = qr_result[i].data
                elif ((qr_result[i].rect[0] >= 110 and qr_result[i].rect[0] <= 150) and (qr_result[i].rect[1] >= 780 and qr_result[i].rect[1] <= 810)):
                    color_dict["packagen30"] = qr_result[i].data
                elif ((qr_result[i].rect[0] >= 300 and qr_result[i].rect[0] <= 330) and (qr_result[i].rect[1] >= 780 and qr_result[i].rect[1] <= 810)):
                    color_dict["packagen31"] = qr_result[i].data
                elif ((qr_result[i].rect[0] >= 490 and qr_result[i].rect[0] <= 520) and (qr_result[i].rect[1] >= 780 and qr_result[i].rect[1] <= 810)):
                    color_dict["packagen32"] = qr_result[i].data
            return color_dict
        else:
            print "NUMBER OF PACKAGES DETECTED IN node_t5: ", self.len_lst
            return color_dict

    # Function definition to unsubscribe from a topic
    def unsubscribe(self):
        '''Unsubscriber function used to unsubscribe from topics'''

        # use the saved subscriber object to unregister the subscriber
        self.image_sub.unregister()

    # Call back function definition
    def callback(self, data):
        '''Callback function called everytime 2D Camera sends data'''

        print "CALLBACK ENTERED"
        try:
            cv_image = self.bridge.imgmsg_to_cv2(data, "bgr8")

        except CvBridgeError as e:
            rospy.logerr(e)

        # (rows, cols, channels) = cv_image.shape

        # cv_image = self.apply_brightness_contrast(cv_image)
        # gray_image = cv2.cvtColor(cv_image, cv2.COLOR_BGR2GRAY)
        contrast_img = cv2.addWeighted(cv_image, 2.5, np.zeros(cv_image.shape, cv_image.dtype), 0, 0)

        cn = 18
        hn = 18
        dictorder_dummy = {}

        dst = cv2.fastNlMeansDenoisingColored(contrast_img, None, cn, hn, 7, 21)
        image = dst
        dictorder_dummy = self.get_qr_data(image)

        # This block sets the optimum parameters for QR Code detection.
        while(len(dictorder_dummy) != 12):
            cn += 1
            hn += 1
            dst = cv2.fastNlMeansDenoisingColored(contrast_img, None, cn, hn, 7, 21)
            image = dst
            dictorder_dummy = self.get_qr_data(image)

        self.dictorder = dictorder_dummy

        # Resize a 720x1280 image to 360x640 to fit it on the screen
        # resized_image_post = cv2.resize(dst, (720/2, 1280/2))
        # cv2.imshow("window_2", resized_image_post)

        print "PACKAGE ORDER", self.dictorder

        cv2.waitKey(0)


class Ur5Moveit:
    '''Main class that initializes the robot arms, configures MoveIt and contains object of action client class'''

    # Constructor
    def __init__(self, arg_robot_name):
        '''Constructor of class Ur5Moveit'''

        rospy.init_node('node_t5', anonymous=True)

        self._robot_ns = '/' + arg_robot_name
        self._planning_group = "manipulator"

        self._commander = moveit_commander.roscpp_initialize(sys.argv)
        self._robot = moveit_commander.RobotCommander(robot_description=self._robot_ns + "/robot_description", ns=self._robot_ns)
        self._scene = moveit_commander.PlanningSceneInterface(ns=self._robot_ns)
        self._group = moveit_commander.MoveGroupCommander(self._planning_group, robot_description=self._robot_ns + "/robot_description", ns=self._robot_ns)
        self._group.set_planning_time(99)
        self._display_trajectory_publisher = rospy.Publisher(self._robot_ns + '/move_group/display_planned_path', moveit_msgs.msg.DisplayTrajectory, queue_size=1)
        self._exectute_trajectory_client = actionlib.SimpleActionClient(self._robot_ns + '/execute_trajectory', moveit_msgs.msg.ExecuteTrajectoryAction)
        self._exectute_trajectory_client.wait_for_server()

        self._planning_frame = self._group.get_planning_frame()
        self._eef_link = self._group.get_end_effector_link()
        self._group_names = self._robot.get_group_names()
        self._box_name = 'box'

        # Attribute to store computed trajectory by the planner
        self._computed_plan = ''

        # Current State of the Robot is needed to add box to planning scene
        self._curr_state = self._robot.get_current_state()

        self.placed_order = []
        self.placed_order_red = []
        self.placed_order_yellow = []
        self.placed_order_green = []

        rospy.loginfo(
            '\033[94m' + "Planning Group: {}".format(self._planning_frame) +
            '\033[0m')
        rospy.loginfo(
            '\033[94m' + "End Effector Link: {}".format(self._eef_link) +
            '\033[0m')
        rospy.loginfo(
            '\033[94m' + "Group Names: {}".format(self._group_names) +
            '\033[0m')

        rp = rospkg.RosPack()
        self._pkg_path = rp.get_path('pkg_task5')
        self._file_path = self._pkg_path + '/config/saved_trajectories/'
        rospy.loginfo("Package Path: {}".format(self._file_path))

        rospy.loginfo('\033[94m' + " >>> Ur5Moveit init done." +
                      '\033[0m')

        # DECLARING OBJECT OF ACTION CLASS HERE
        self.action_client = IotRosBridgeActionClient()

        # define variable for updating handle values
        self.i = 0

        # Read and Store IoT Configuration data from Parameter Server
        param_config_iot = rospy.get_param('config_iot')
        self._config_mqtt_server_url = param_config_iot['mqtt']['server_url']
        self._config_mqtt_server_port = param_config_iot['mqtt']['server_port']
        self._config_mqtt_sub_topic = param_config_iot['mqtt']['topic_sub']
        self._config_mqtt_pub_topic = param_config_iot['mqtt']['topic_pub']
        self._config_mqtt_qos = param_config_iot['mqtt']['qos']
        self._config_mqtt_getting_orders = param_config_iot['mqtt']['getting_orders_topic']
        self._config_mqtt_sub_cb_ros_topic = param_config_iot['mqtt']['sub_cb_ros_topic']
        print param_config_iot

        rospy.Subscriber("/ros_iot_bridge/mqtt/sub", msgMqttSub,
                         self.sub_callback)

    def sub_callback(self, msg):
        '''Callback function called everytime mqtt topic receives new orders'''

        payload = msg.message
        dict_payload = json.loads(payload)
        print("PRINTING PAYLOAD FROM NEW NODE_T5", dict_payload)
        self.placed_order.append(dict_payload)

        if dict_payload['item'] == 'Medicine':
            self.placed_order_red.append(dict_payload)
        elif dict_payload['item'] == 'Food':
            self.placed_order_yellow.append(dict_payload)
        elif dict_payload['item'] == 'Clothes':
            self.placed_order_green.append(dict_payload)

    def clear_octomap(self):
        '''Clears the octomap'''
        clear_octomap_service_proxy = rospy.ServiceProxy(self._robot_ns + "/clear_octomap", Empty)
        return clear_octomap_service_proxy()

    def hard_set_joint_angles(self, arg_list_joint_angles, arg_max_attempts):
        '''Function to set joint angles of arm with choice number of attempts'''

        number_attempts = 0
        flag_success = False

        while ((number_attempts <= arg_max_attempts) and (flag_success is False)):
            number_attempts += 1
            flag_success = self.set_joint_angles(arg_list_joint_angles)
            rospy.logwarn("attempts: {}".format(number_attempts))

    def set_joint_angles(self, arg_list_joint_angles):
        '''Function to set Joint angles of the arm'''

        # list_joint_values = self._group.get_current_joint_values()
        # rospy.loginfo('\033[94m' + ">>> Current Joint Values:" + '\033[0m')
        # rospy.loginfo(list_joint_values)

        self._group.set_joint_value_target(arg_list_joint_angles)
        self._group.plan()
        flag_plan = self._group.go(wait=True)

        list_joint_values = self._group.get_current_joint_values()
        # rospy.loginfo('\033[94m' + ">>> Final Joint Values:" + '\033[0m')
        # rospy.loginfo(list_joint_values)

        # pose_values = self._group.get_current_pose().pose
        # rospy.loginfo('\033[94m' + ">>> Final Pose:" + '\033[0m')
        # rospy.loginfo(pose_values)

        if flag_plan is True:
            pass
            # rospy.loginfo(# '\033[94m' + ">>> set_joint_angles() Success" +'\033[0m')
        else:
            pass
            # rospy.logerr(# '\033[94m' + ">>> set_joint_angles() Failed." + '\033[0m')

        return flag_plan

    def moveit_play_planned_path_from_file(self, arg_file_path, arg_file_name):
        '''Plays pre recorded path'''

        file_path = arg_file_path + arg_file_name

        with open(file_path, 'r') as file_open:
            loaded_plan = yaml.load(file_open)

        ret = self._group.execute(loaded_plan)
        # rospy.logerr(ret)
        return ret

    def moveit_hard_play_planned_path_from_file(self, arg_file_path, arg_file_name, arg_max_attempts):
        '''Plays pre recorded paths with choice number of attempts'''
        number_attempts = 0
        flag_success = False

        while ((number_attempts <= arg_max_attempts) and (flag_success is False)):
            number_attempts += 1
            flag_success = self.moveit_play_planned_path_from_file(arg_file_path, arg_file_name)
            rospy.logwarn("attempts: {}".format(number_attempts))
            # # self.clear_octomap()

        return True

    # Function definition to attach or detach package to vacuumGripper
    def attach_or_detach_to_vg(self, vg_flag=False):
        '''Attaches/Detaches packages to vacuum gripper'''

        rospy.wait_for_service('/eyrc/vb/ur5/activate_vacuum_gripper/ur5_1')
        try:
            grip = rospy.ServiceProxy('/eyrc/vb/ur5/activate_vacuum_gripper/ur5_1', vacuumGripper)
            grip1 = grip(vg_flag)
            return grip1.result
        except:
            print "Service call failed for attach"

    # Destructor
    def __del__(self):
        '''Deletes object of class'''

        moveit_commander.roscpp_shutdown()
        rospy.loginfo(
            '\033[94m' + "Object of class Ur5Moveit Deleted." + '\033[0m')

    def func_packages(self, pkg_name, new_dict):
        '''Goes to package on shelf based on orders recieved takes package name and orders dictionary as arguments'''

        if pkg_name == "packagen00":
            #  Picking Package 00 from the shelf
            all_zero_list = [math.radians(0.00),
                             math.radians(0.00),
                             math.radians(0.00),
                             math.radians(0.00),
                             math.radians(0.00),
                             math.radians(0.00)]

            # self.hard_set_joint_angles(all_zero_list, 5)

            rospy.logwarn("1. Playing Home to Pose#1 Trajectory File")
            self.moveit_hard_play_planned_path_from_file(self._file_path,
                                                         'HOME_TO_packagen00_NEW.yaml',
                                                         5)
            # rospy.sleep(2)
            attach = self.attach_or_detach_to_vg(True)
            if attach:
                rospy.logwarn("2.Playing Packagen00 to Home Trajectory File")
                self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen00_to_home.yaml', 5)
                self.attach_or_detach_to_vg(False)

                mesg = json.dumps(new_dict)
                goal_handle0 = self.action_client.send_goal("mqtt", "pub_dispatch", self.action_client._config_mqtt_pub_topic, mesg)    # sending message to bridge server
                # updating goal handle
                self.action_client._goal_handles[self.i] = goal_handle0
                self.i += 1
                rospy.loginfo("Goal #" + str(self.i-1) + " Sent")
                rospy.sleep(1)

        if pkg_name == "packagen01":
            #  Picking Package 01 from the shelf

            # self.hard_set_joint_angles(home_pos_list, 5)
            attached_2 = 0
            rospy.logwarn("1. Playing Home to Pkg2 Trajectory File")
            self.moveit_hard_play_planned_path_from_file(self._file_path,
                                                         'home_to_pkg2.yaml',
                                                         5)
            attached_2 = self.attach_or_detach_to_vg(True)
            if attached_2:
                rospy.logwarn("2.Playing Packagen01 to Home Trajectory File")
                self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen01_to_home.yaml', 5)
                self.attach_or_detach_to_vg(False)

                mesg = json.dumps(new_dict)
                goal_handle1 = self.action_client.send_goal("mqtt", "pub_dispatch", self.action_client._config_mqtt_pub_topic, mesg)    # sending message to bridge server
                # updating goal handle
                self.action_client._goal_handles[self.i] = goal_handle1
                self.i += 1
                rospy.loginfo("Goal #" + str(self.i-1) + " Sent")
                rospy.sleep(1)

        if pkg_name == "packagen02":
            #  Picking Package 02 from the shelf

            # self.hard_set_joint_angles(home_pos_list, 5)
            attched_3 = 0
            rospy.logwarn("1. Playing Home to Pkg3 Trajectory File")
            self.moveit_hard_play_planned_path_from_file(self._file_path,
                                                         'home_to_pkg3.yaml',
                                                         5)
            attached_3 = self.attach_or_detach_to_vg(True)
            if attached_3:
                rospy.logwarn("1. Playing Pkg3 to Home Trajectory File")
                self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen02_to_home.yaml', 5)
                self.attach_or_detach_to_vg(False)

                mesg = json.dumps(new_dict)
                goal_handle2 = self.action_client.send_goal("mqtt", "pub_dispatch", self.action_client._config_mqtt_pub_topic, mesg)    # sending message to bridge server
                # updating goal handle
                self.action_client._goal_handles[self.i] = goal_handle2
                self.i += 1
                rospy.loginfo("Goal #" + str(self.i-1) + " Sent")
                rospy.sleep(1)

        if pkg_name == "packagen10":
            #  Picking Package 10 from the shelf

            # self.hard_set_joint_angles(home_pos_list, 5)
            attached_4 = 0
            rospy.logwarn("1. Playing Home to Pkg4 Trajectory File")
            self.moveit_hard_play_planned_path_from_file(self._file_path,
                                                         'home_to_pkg4.yaml',
                                                         5)
            attached_4 = self.attach_or_detach_to_vg(True)
            if attached_4:
                rospy.logwarn("1. Playing Pkg4 to Home Trajectory File")
                self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen10_to_home.yaml', 5)
                self.attach_or_detach_to_vg(False)

                mesg = json.dumps(new_dict)
                goal_handle3 = self.action_client.send_goal("mqtt", "pub_dispatch", self.action_client._config_mqtt_pub_topic, mesg)    # sending message to bridge server
                # updating goal handle
                self.action_client._goal_handles[self.i] = goal_handle3
                self.i += 1
                rospy.loginfo("Goal #" + str(self.i-1) + " Sent")
                rospy.sleep(1)

        if pkg_name == "packagen11":
            #  Picking Package 11 from the shelf

            # self.hard_set_joint_angles(home_pos_list, 5)
            attached_5 = 0
            rospy.logwarn("1. Playing Home to Pkg5 Trajectory File")
            self.moveit_hard_play_planned_path_from_file(self._file_path,
                                                         'home_to_pkg5.yaml',
                                                         5)
            attached_5 = self.attach_or_detach_to_vg(True)
            if attached_5:
                rospy.logwarn("1. Playing Pkg5 to Home Trajectory File")
                self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen11_to_home.yaml', 5)
                self.attach_or_detach_to_vg(False)

                mesg = json.dumps(new_dict)
                goal_handle4 = self.action_client.send_goal("mqtt", "pub_dispatch", self.action_client._config_mqtt_pub_topic, mesg)    # sending message to bridge server
                # updating goal handle
                self.action_client._goal_handles[self.i] = goal_handle4
                self.i += 1
                rospy.loginfo("Goal #" + str(self.i-1) + " Sent")
                rospy.sleep(1)

        if pkg_name == "packagen12":
            #  Picking Package 12 from the shelf

            # self.hard_set_joint_angles(home_pos_list, 5)
            attached_6 = 0
            rospy.logwarn("1. Playing Home to Pkg6 Trajectory File")
            self.moveit_hard_play_planned_path_from_file(self._file_path,
                                                         'home_to_pkg6.yaml',
                                                         5)
            attached_6 = self.attach_or_detach_to_vg(True)
            if attached_6:
                rospy.logwarn("1. Playing Pkg6 to Home Trajectory File")
                self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen12_to_home.yaml', 5)
                self.attach_or_detach_to_vg(False)

                mesg = json.dumps(new_dict)
                goal_handle5 = self.action_client.send_goal("mqtt", "pub_dispatch", self.action_client._config_mqtt_pub_topic, mesg)    # sending message to bridge server
                # updating goal handle
                self.action_client._goal_handles[self.i] = goal_handle5
                self.i += 1
                rospy.loginfo("Goal #" + str(self.i-1) + " Sent")
                rospy.sleep(1)

        if pkg_name == "packagen30":
            #  Picking Package 30 from the shelf

            # self.hard_set_joint_angles(home_pos_list, 5)
            rospy.logwarn("1. Playing Home to Pkg10 Trajectory File")
            self.moveit_hard_play_planned_path_from_file(self._file_path, 'home_to_pkg10.yaml', 5)
            attached_10 = 0
            attached_10 = self.attach_or_detach_to_vg(True)
            if attached_10:
                rospy.logwarn("1. Playing Pkg10 to cartesian Trajectory File")
                self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen30_to_cartesian_ALTERNATE.yaml', 5)
                rospy.logwarn("1. Playing Pkg10 cartesian to home Trajectory File")
                self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen30_cartesian_to_home_ALTERNATE.yaml', 5)
                self.attach_or_detach_to_vg(False)

                mesg = json.dumps(new_dict)
                goal_handle6 = self.action_client.send_goal("mqtt", "pub_dispatch", self.action_client._config_mqtt_pub_topic, mesg)    # sending message to bridge server
                self.action_client._goal_handles[self.i] = goal_handle6                                        # updating goal handle
                self.i += 1
                rospy.loginfo("Goal #" + str(self.i-1) + " Sent")
                rospy.sleep(1)

        if pkg_name == "packagen31":
            #  Picking Package 31 from the shelf

            # self.hard_set_joint_angles(home_pos_list, 5)
            rospy.logwarn("1. Playing Home to Pkg11 Trajectory File")
            self.moveit_hard_play_planned_path_from_file(self._file_path,
                                                         'home_to_pkg11.yaml',
                                                         5)
            attached_11 = 0
            attached_11 = self.attach_or_detach_to_vg(True)
            if attached_11:
                rospy.logwarn("1. Playing Pkg11 to cartesian Trajectory File")
                self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen31_to_cartesian_ALTERNATE.yaml', 5)
                rospy.logwarn("1. Playing Pkg11 cartesian to home Trajectory File")
                self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen31_cartesian_to_home_ALTERNATE.yaml', 5)
                self.attach_or_detach_to_vg(False)

                mesg = json.dumps(new_dict)
                goal_handle7 = self.action_client.send_goal("mqtt", "pub_dispatch", self.action_client._config_mqtt_pub_topic, mesg)    # sending message to bridge server
                # updating goal handle
                self.action_client._goal_handles[self.i] = goal_handle7
                self.i += 1
                rospy.loginfo("Goal #" + str(self.i-1) + " Sent")
                rospy.sleep(1)

        if pkg_name == "packagen32":
            #  Picking Package 32 from the shelf

            # self.hard_set_joint_angles(home_pos_list, 5)
            attached_12 = 0
            rospy.logwarn("1. Playing Home to Pkg12 Trajectory File")
            self.moveit_hard_play_planned_path_from_file(self._file_path,
                                                         'home_to_pkg12.yaml',
                                                         5)
            attached_12 = self.attach_or_detach_to_vg(True)
            if attached_12:
                rospy.logwarn("1. Playing Pkg32  to cartesian Trajectory File")
                self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen32_to_cartesian.yaml', 5)
                rospy.logwarn("1. Playing  cartesian to home Trajectory File")
                self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen32_cartesian_to_home.yaml', 5)
                self.attach_or_detach_to_vg(False)

                mesg = json.dumps(new_dict)
                goal_handle8 = self.action_client.send_goal("mqtt", "pub_dispatch", self.action_client._config_mqtt_pub_topic, mesg)    # sending message to bridge server
                # updating goal handle
                self.action_client._goal_handles[self.i] = goal_handle8
                self.i += 1
                rospy.loginfo("Goal #" + str(self.i-1) + " Sent")
                rospy.sleep(1)


def main():

    rospy.sleep(20)

    ur5 = Ur5Moveit(sys.argv[1])

    ic = Camera1()

    lst_red = []
    lst_green = []
    lst_yellow = []

    # This block is used to wait until all 12 packages are detected.
    while True:
        if(ic.len_lst == 12):
            # Unsubscribing
            ic.unsubscribe()
            # Sort the detected packages into respective lists based on color
            dict_order_temp = ic.dictorder
            break

    print "PRINTING DICTORDER", dict_order_temp
    for i in dict_order_temp.items():
        if i[1] == "red":
            lst_red.append(i)
        elif i[1] == "yellow":
            lst_yellow.append(i)
        elif i[1] == "green":
            lst_green.append(i)

    lst_red.sort(key=lambda x: x[0])
    lst_yellow.sort(key=lambda x: x[0])
    lst_green.sort(key=lambda x: x[0])
    lst_red.pop(2)
    lst_yellow.pop(2)
    lst_green.pop(2)
    print "PRINTING SORTED LISTS", lst_red, lst_yellow, lst_green

    # Define position above conveyor belt
    home_pos_list = [math.radians(7.838),
                     math.radians(-139.943),
                     math.radians(-58.278),
                     math.radians(-71.819),
                     math.radians(89.975),
                     math.radians(7.833)]

    ur5.hard_set_joint_angles(home_pos_list, 5)

    # Used for traversing the list of dictionaries
    i = 0

    while not rospy.is_shutdown():

        if ur5.placed_order != []:

            while i < len(ur5.placed_order):
                if ur5.placed_order_red != []:
                    var_flag = lst_red[0][0]
                    ur5.func_packages(var_flag, ur5.placed_order_red[0])
                    ur5.placed_order_red.pop(0)
                    lst_red.pop(0)
                    i += 1

                elif ur5.placed_order_yellow != []:
                    var_flag = lst_yellow[0][0]
                    ur5.func_packages(var_flag, ur5.placed_order_yellow[0])
                    ur5.placed_order_yellow.pop(0)
                    lst_yellow.pop(0)
                    i += 1

                elif ur5.placed_order_green != []:
                    var_flag = lst_green[0][0]
                    ur5.func_packages(var_flag, ur5.placed_order_green[0])
                    ur5.placed_order_green.pop(0)
                    lst_green.pop(0)
                    i += 1
    del ur5


if __name__ == '__main__':
    main()
