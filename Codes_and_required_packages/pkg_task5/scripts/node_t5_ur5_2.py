#! /usr/bin/env python

import os
import math
import sys
import copy
import threading
import json

import time
from time import gmtime, strftime
from datetime import date, datetime, timedelta

import rospy
import moveit_commander
import moveit_msgs.msg
import geometry_msgs.msg
import actionlib
import rospkg
import yaml

from tf.transformations import euler_from_quaternion, quaternion_from_euler

import numpy as np
from std_msgs.msg import String
from sensor_msgs.msg import Image
from cv_bridge import CvBridge, CvBridgeError

from pyzbar.pyzbar import decode

from std_srvs.srv import Empty

# Message Class used by ROS Actions internally
from pkg_ros_iot_bridge.msg import msgRosIotAction
# Message Class used for Goal Messages
from pkg_ros_iot_bridge.msg import msgRosIotGoal
from pkg_ros_iot_bridge.msg import msgRosIotResult
from pkg_ros_iot_bridge.msg import msgMqttSub

from pkg_vb_sim.srv import vacuumGripper
from pkg_vb_sim.srv import ConveyorBeltControl
from pkg_vb_sim.srv import conveyorBeltPowerMsg
from pkg_vb_sim.msg import LogicalCameraImage

import cv2


class IotRosBridgeActionClient:
    '''This class is responsible for using the node as an action client'''

    # Constructor
    def __init__(self):

        # Initialize Action Client
        self._ac = actionlib.ActionClient('/action_ros_iot', msgRosIotAction)
        # Dictionary to Store all the goal handels
        self._goal_handles = {}

        # Store the MQTT Topic on which to Publish in a variable
        param_config_iot = rospy.get_param('config_iot')
        self._config_mqtt_sub_topic = param_config_iot['mqtt']['topic_sub']
        self._config_mqtt_pub_topic = param_config_iot['mqtt']['topic_pub']
        self._config_MQTT = param_config_iot['mqtt']['sub_cb_ros_topic']
        # Wait for Action Server that will use
        # the action - '/action_iot_ros' to start
        self._ac.wait_for_server()
        rospy.loginfo("Action server up, we can send goals.")

    def on_transition(self, goal_handle):
        '''This function will be called when there is a change of
        state in the Action Client State Machine'''

        # from on_goal() to on_transition(). goal_handle generated by
        # send_goal() is used here.
        result = msgRosIotResult()
        index = 0
        for i in self._goal_handles:
            if self._goal_handles[i] == goal_handle:
                index = i
                break

        rospy.loginfo("Transition Callback. Client Goal Handle #: " +
                      str(index))
        rospy.loginfo("Comm. State: " + str(goal_handle.get_comm_state()))
        rospy.loginfo("Goal Status: " + str(goal_handle.get_goal_status()))
        # Comm State - Monitors the State Machine of the Client
        # which is different from Server's
        # Comm State = 2 -> Active
        # Comm State = 3 -> Wating for Result
        # Comm State = 7 -> Done
        # if (Comm State == ACTIVE)
        if goal_handle.get_comm_state() == 2:
            rospy.loginfo(str(index) + ": Goal just went active.")
        # if (Comm State == DONE)
        if goal_handle.get_comm_state() == 7:
            rospy.loginfo(str(index) + ": Goal is DONE")
            rospy.loginfo(goal_handle.get_terminal_state())
            # get_result() gets the result produced by the Action Server
            result = goal_handle.get_result()
            rospy.loginfo(result.flag_success)

            if result.flag_success:
                rospy.loginfo("Goal successfully completed. Client Goal Handle #: " + str(index))
            else:
                rospy.loginfo("Goal failed. Client Goal Handle #: " +
                              str(index))

    # This function is used to send Goals to Action Server
    def send_goal(self, arg_protocol, arg_mode, arg_topic, arg_message):
        '''This function is used to send Goals to Action Server'''

        # Create a Goal Message object
        goal = msgRosIotGoal()

        goal.protocol = arg_protocol
        goal.mode = arg_mode
        goal.topic = arg_topic
        goal.message = arg_message

        rospy.loginfo("Send goal.")
        # self.on_transition - It is a function pointer to a
        # function which will be called when
        # there is a change of state in the Action Client State Machine
        goal_handle = self._ac.send_goal(goal,
                                         self.on_transition,
                                         None)

        return goal_handle


class Camera1:
    '''This class performs image processing tasks'''

    def __init__(self):
        '''Constructor of class Camera1'''

        self.bridge = CvBridge()
        self.image_sub = rospy.Subscriber("/eyrc/vb/camera_1/image_raw",
                                          Image, self.callback)
        self.dictorder = {}
        self.len_lst = 0

    # Qr Code decode function
    def get_qr_data(self, arg_image):
        '''Decodes the qr code'''

        qr_result = decode(arg_image)
        self.len_lst = len(qr_result)
        color_dict = {}

        if self.len_lst == 12:
            print "DETECTED 12 PACKAGES IN node_t5_ur5_2"

            for i in range(self.len_lst):
                if (qr_result[i].rect[0] >= 110 and qr_result[i].rect[0] <= 150) and (qr_result[i].rect[1] >= 290 and qr_result[i].rect[1] <= 340):
                    color_dict["packagen00"] = qr_result[i].data
                elif (qr_result[i].rect[0] >= 300 and qr_result[i].rect[0] <= 330) and (qr_result[i].rect[1] >= 290 and qr_result[i].rect[1] <= 340):
                    color_dict["packagen01"] = qr_result[i].data
                elif (qr_result[i].rect[0] >= 490 and qr_result[i].rect[0] <= 520) and (qr_result[i].rect[1] >= 290 and qr_result[i].rect[1] <= 340):
                    color_dict["packagen02"] = qr_result[i].data
                elif (qr_result[i].rect[0] >= 110 and qr_result[i].rect[0] <= 150) and (qr_result[i].rect[1] >= 480 and qr_result[i].rect[1] <= 520):
                    color_dict["packagen10"] = qr_result[i].data
                elif (qr_result[i].rect[0] >= 300 and qr_result[i].rect[0] <= 330) and (qr_result[i].rect[1] >= 480 and qr_result[i].rect[1] <= 520):
                    color_dict["packagen11"] = qr_result[i].data
                elif (qr_result[i].rect[0] >= 490 and qr_result[i].rect[0] <= 520) and (qr_result[i].rect[1] >= 480 and qr_result[i].rect[1] <= 520):
                    color_dict["packagen12"] = qr_result[i].data
                elif (qr_result[i].rect[0] >= 110 and qr_result[i].rect[0] <= 150) and (qr_result[i].rect[1] >= 630 and qr_result[i].rect[1] <= 660):
                    color_dict["packagen20"] = qr_result[i].data
                elif (qr_result[i].rect[0] >= 300 and qr_result[i].rect[0] <= 330) and (qr_result[i].rect[1] >= 630 and qr_result[i].rect[1] <= 660):
                    color_dict["packagen21"] = qr_result[i].data
                elif (qr_result[i].rect[0] >= 490 and qr_result[i].rect[0] <= 520) and (qr_result[i].rect[1] >= 630 and qr_result[i].rect[1] <= 660):
                    color_dict["packagen22"] = qr_result[i].data
                elif (qr_result[i].rect[0] >= 110 and qr_result[i].rect[0] <= 150) and (qr_result[i].rect[1] >= 780 and qr_result[i].rect[1] <= 810):
                    color_dict["packagen30"] = qr_result[i].data
                elif (qr_result[i].rect[0] >= 300 and qr_result[i].rect[0] <= 330) and (qr_result[i].rect[1] >= 780 and qr_result[i].rect[1] <= 810):
                    color_dict["packagen31"] = qr_result[i].data
                elif (qr_result[i].rect[0] >= 490 and qr_result[i].rect[0] <= 520) and (qr_result[i].rect[1] >= 780 and qr_result[i].rect[1] <= 810):
                    color_dict["packagen32"] = qr_result[i].data

            return color_dict
        else:
            print "NUMBER OF PACKAGES DETECTED IN node_t5_ur5_2 :", self.len_lst
            return color_dict

    # Function definition to unsubscribe from a topic
    def unsubscribe(self):
        '''Unsubscriber function used to unsubscribe from topics'''

        # use the saved subscriber object to unregister the subscriber
        self.image_sub.unregister()

    # Call back function definition
    def callback(self, data):
        '''Callback function called everytime 2D Camera sends data'''

        try:
            cv_image = self.bridge.imgmsg_to_cv2(data, "bgr8")

        except CvBridgeError as e:
            rospy.logerr(e)

        # (rows, cols, channels) = cv_image.shape

        # contrast_img = cv2.addWeighted(cv_image, 0.8, np.zeros(cv_image.shape, cv_image.dtype), 0.2, 0)
        contrast_img = cv2.addWeighted(cv_image, 2.5, np.zeros(cv_image.shape, cv_image.dtype), 0, 0)

        cn = 18
        hn = 18
        dictorder_dummy = {}

        dst = cv2.fastNlMeansDenoisingColored(contrast_img, None, cn, hn, 7, 21)
        image = dst
        dictorder_dummy = self.get_qr_data(image)

        # This block sets the optimum parameters for QR Code detection.
        while(len(dictorder_dummy) != 12):
            cn += 1
            hn += 1
            dst = cv2.fastNlMeansDenoisingColored(contrast_img, None, cn, hn, 7, 21)
            image = dst
            dictorder_dummy = self.get_qr_data(image)

        self.dictorder = dictorder_dummy

        # Resize a 720x1280 image to 360x640 to fit it on the screen
        # resized_image_post = cv2.resize(dst, (720/2, 1280/2))
        # cv2.imshow("window_2", resized_image_post)

        print "PACKAGE ORDER", self.dictorder

        # rospy.loginfo(self.get_qr_data(image))

        cv2.waitKey(0)


class Ur5Moveit:
    '''Main class that initializes the robot arms, configures MoveIt and contains object of action client class'''

    # Constructor
    def __init__(self, arg_robot_name):
        '''Constructor of class Ur5Moveit'''

        rospy.init_node('node_t5_ur5_2', anonymous=True)

        self._robot_ns = '/' + arg_robot_name
        self._planning_group = "manipulator"

        self._commander = moveit_commander.roscpp_initialize(sys.argv)
        self._robot = moveit_commander.RobotCommander(robot_description=self._robot_ns + "/robot_description", ns=self._robot_ns)
        self._scene = moveit_commander.PlanningSceneInterface(ns=self._robot_ns)
        self._group = moveit_commander.MoveGroupCommander(self._planning_group, robot_description=self._robot_ns + "/robot_description", ns=self._robot_ns)
        self._display_trajectory_publisher = rospy.Publisher(self._robot_ns + '/move_group/display_planned_path', moveit_msgs.msg.DisplayTrajectory, queue_size=1)
        self._exectute_trajectory_client = actionlib.SimpleActionClient(self._robot_ns + '/execute_trajectory', moveit_msgs.msg.ExecuteTrajectoryAction)
        self._exectute_trajectory_client.wait_for_server()

        self._planning_frame = self._group.get_planning_frame()
        self._eef_link = self._group.get_end_effector_link()
        self._group_names = self._robot.get_group_names()
        self._box_name = 'box'
        self.pkg_name = None
        self.pick_condition = 0
        self.placed_order = {}
        self.package_order = {}
        self.lst_red = []
        self.lst_green = []
        self.lst_yellow = []

        # Attribute to store computed trajectory by the planner
        self._computed_plan = ''

        # Current State of the Robot is needed to add box to planning scene
        self._curr_state = self._robot.get_current_state()

        rospy.loginfo(
            '\033[94m' + "Planning Group: {}".format(self._planning_frame) +
            '\033[0m')
        rospy.loginfo(
            '\033[94m' + "End Effector Link: {}".format(self._eef_link) +
            '\033[0m')
        rospy.loginfo(
            '\033[94m' + "Group Names: {}".format(self._group_names) +
            '\033[0m')

        rp = rospkg.RosPack()
        self._pkg_path = rp.get_path('pkg_task5')
        self._file_path = self._pkg_path + '/config/saved_trajectories/'
        rospy.loginfo("Package Path: {}".format(self._file_path))
        rospy.loginfo('\033[94m' + " >>> Ur5Moveit init done." + '\033[0m')

        # DECLARING OBJECT OF ACTION CLASS HERE
        self.action_client = IotRosBridgeActionClient()

        # define variable for updating handle values
        self.i = 0

        # Read and Store IoT Configuration data from Parameter Server
        param_config_iot = rospy.get_param('config_iot')
        self._config_mqtt_server_url = param_config_iot['mqtt']['server_url']
        self._config_mqtt_server_port = param_config_iot['mqtt']['server_port']
        self._config_mqtt_sub_topic = param_config_iot['mqtt']['topic_sub']
        self._config_mqtt_pub_topic = param_config_iot['mqtt']['topic_pub']
        self._config_mqtt_qos = param_config_iot['mqtt']['qos']
        self._config_mqtt_getting_orders = param_config_iot['mqtt']['getting_orders_topic']
        self._config_mqtt_sub_cb_ros_topic = param_config_iot['mqtt']['sub_cb_ros_topic']
        print param_config_iot

        rospy.Subscriber("/ros_iot_bridge/mqtt/sub", msgMqttSub,
                         self.local_mqtt_sub_callback)

    def local_mqtt_sub_callback(self, msg):
        '''Callback function called everytime mqtt topic receives new orders'''

        payload = msg.message
        dict_payload = json.loads(payload)
        print "PRINTING PAYLOAD FROM NEW NODE_T5_UR5_2", dict_payload
        # self.placed_order = dict_payload

        if dict_payload["item"] == "Medicine":
            self.lst_red.append(dict_payload)

        elif dict_payload["item"] == "Food":
            self.lst_yellow.append(dict_payload)

        elif dict_payload["item"] == "Clothes":
            self.lst_green.append(dict_payload)

    def clear_octomap(self):
        clear_octomap_service_proxy = rospy.ServiceProxy(self._robot_ns +
                                                         "/clear_octomap",
                                                         Empty)
        return clear_octomap_service_proxy()

    def hard_set_joint_angles(self, arg_list_joint_angles, arg_max_attempts):
        '''Function to set joint angles of arm with choice number of attempts'''

        number_attempts = 0
        flag_success = False

        while ((number_attempts <= arg_max_attempts) and (flag_success is False)):
            number_attempts += 1
            flag_success = self.set_joint_angles(arg_list_joint_angles)
            rospy.logwarn("attempts: {}".format(number_attempts))

    def set_joint_angles(self, arg_list_joint_angles):
        '''Function to set Joint angles of the arm'''

        list_joint_values = self._group.get_current_joint_values()
        rospy.loginfo('\033[94m' + ">>> Current Joint Values:" + '\033[0m')
        rospy.loginfo(list_joint_values)

        self._group.set_joint_value_target(arg_list_joint_angles)
        self._group.plan()
        flag_plan = self._group.go(wait=True)

        list_joint_values = self._group.get_current_joint_values()
        rospy.loginfo('\033[94m' + ">>> Final Joint Values:" + '\033[0m')
        rospy.loginfo(list_joint_values)

        pose_values = self._group.get_current_pose().pose
        rospy.loginfo('\033[94m' + ">>> Final Pose:" + '\033[0m')
        rospy.loginfo(pose_values)

        if flag_plan:
            rospy.loginfo(
                '\033[94m' + ">>> set_joint_angles() Success" + '\033[0m')
        else:
            rospy.logerr(
                '\033[94m' + ">>> set_joint_angles() Failed." + '\033[0m')

        return flag_plan

    def moveit_play_planned_path_from_file(self, arg_file_path, arg_file_name):
        '''Plays pre recorded path'''

        file_path = arg_file_path + arg_file_name

        with open(file_path, 'r') as file_open:
            loaded_plan = yaml.load(file_open)

        ret = self._group.execute(loaded_plan)
        # rospy.logerr(ret)
        return ret

    def moveit_hard_play_planned_path_from_file(self, arg_file_path, arg_file_name, arg_max_attempts):
        '''Plays pre recorded paths with choice number of attempts'''

        number_attempts = 0
        flag_success = False

        while ((number_attempts <= arg_max_attempts) and (flag_success is False)):
            number_attempts += 1
            flag_success = self.moveit_play_planned_path_from_file(arg_file_path, arg_file_name)
            rospy.logwarn("attempts: {}".format(number_attempts))
            # # self.clear_octomap()

        return True

    # Function definition to attach or detach package to vacuumGripper
    def attach_or_detach_to_vg(self, vg_flag=False):
        '''Attaches/Detaches packages to vacuum gripper'''

        rospy.wait_for_service('/eyrc/vb/ur5/activate_vacuum_gripper/ur5_2')
        try:
            grip = rospy.ServiceProxy('/eyrc/vb/ur5/activate_vacuum_gripper/ur5_2', vacuumGripper)
            grip1 = grip(vg_flag)
            return grip1.result
        except:
            print "Service call failed for attach"

    # Function definition to start and stop conveyor
    def start_or_stop_conveyor(self, power=0):
        '''Starts and stops conveyor by calling the service'''

        rospy.wait_for_service('/eyrc/vb/conveyor/set_power')
        try:
            start = rospy.ServiceProxy('/eyrc/vb/conveyor/set_power',
                                       conveyorBeltPowerMsg)
            start1 = start(power)
            return start1.result
        except:
            print "Service failed for conveyor"

    # Call back function definition
    def sub_callback(self, msg):
        '''Callback for logical camera 2'''

        # If Red package is detcted
        self.pkg_lst = ["packagen00", "packagen01", "packagen02", "packagen10",
                        "packagen11", "packagen12", "packagen20", "packagen21",
                        "packagen22", "packagen30", "packagen31", "packagen32"]

        try:

            self.pkg_name = msg.models[-1].type

            if msg.models != []:
                yn = msg.models[-1].pose.position.y
                xn = msg.models[-1].pose.position.x
                if yn <= 0:  # Check if package is below logical_camera_2
                    self.pick_condition = 1
                else:
                    self.pick_condition = 0
        except:
            pass

    # Destructor
    def __del__(self):
        '''Deletes object of class'''

        moveit_commander.roscpp_shutdown()
        rospy.loginfo(
            '\033[94m' + "Object of class Ur5Moveit Deleted." + '\033[0m')


def main():

    rospy.sleep(20)

    ur5 = Ur5Moveit(sys.argv[1])

    ur5.start_or_stop_conveyor(100)

    ic = Camera1()

    # This block is used to wait until all 12 packages are detected.
    while True:
        if ic.len_lst == 12:
            # Unsubscribing
            ic.unsubscribe()
            break

    attach_flag_red = 0
    attach_flag_green = 0
    attach_flag_yellow = 0

    rospy.Subscriber("/eyrc/vb/logical_camera_2", LogicalCameraImage,
                     ur5.sub_callback)

    for item in ic.dictorder.items():
        if item[1] == "red":
            # defining our sheet name in the 'id' variable and the the column where we want to update the value
            parameters = {"id": "Inventory", "Team Id": "VB#0302",
                          "Unique Id": "JAADjaad", "SKU": "R" +
                          str(item[0][-2:])+strftime("%m", gmtime()) +
                          strftime("%y", gmtime()), "Item": "Medicine",
                          "Priority": "HP", "Storage Number": "R" +
                          str(item[0][-2]) + " C" + str(item[0][-1]),
                          "Cost": 450, "Quantity": 1}
            mesg = json.dumps(parameters)
            # sending message to bridge server
            goal_handle = ur5.action_client.send_goal("mqtt", "pub_inventory", ur5.action_client._config_mqtt_pub_topic, mesg)
            # updating goal handle
            ur5.action_client._goal_handles[ur5.i] = goal_handle
            ur5.i += 1
            rospy.loginfo("Goal #" + str(ur5.i-1) + " Sent")
            rospy.sleep(2)

        elif item[1] == "yellow":
            # defining our sheet name in the 'id' variable and
            # the column where we want to update the value
            parameters = {"id": "Inventory", "Team Id": "VB#0302",
                          "Unique Id": "JAADjaad", "SKU": "Y" +
                          str(item[0][-2:]) + strftime("%m", gmtime()) +
                          strftime("%y", gmtime()), "Item": "Food",
                          "Priority": "MP", "Storage Number": "R" +
                          str(item[0][-2]) + " C"+str(item[0][-1]),
                          "Cost": 250, "Quantity": 1}
            mesg = json.dumps(parameters)
            goal_handle = ur5.action_client.send_goal("mqtt", "pub_inventory", ur5.action_client._config_mqtt_pub_topic, mesg)    # sending message to bridge server
            # updating goal handle
            ur5.action_client._goal_handles[ur5.i] = goal_handle
            ur5.i += 1
            rospy.loginfo("Goal #" + str(ur5.i-1) + " Sent")
            rospy.sleep(2)

        elif item[1] == "green":
            # defining our sheet name in the 'id' variable and the the column where we want to update the value
            parameters = {"id": "Inventory", "Team Id": "VB#0302",
                          "Unique Id": "JAADjaad", "SKU": "G" +
                          str(item[0][-2:]) + strftime("%m", gmtime()) +
                          strftime("%y", gmtime()), "Item": "Clothes",
                          "Priority": "LP", "Storage Number": "R" +
                          str(item[0][-2]) + " C"+str(item[0][-1]),
                          "Cost": 150, "Quantity": 1}
            mesg = json.dumps(parameters)
            goal_handle = ur5.action_client.send_goal("mqtt", "pub_inventory", ur5.action_client._config_mqtt_pub_topic, mesg)    # sending message to bridge server
            # updating goal handle
            ur5.action_client._goal_handles[ur5.i] = goal_handle
            ur5.i += 1
            rospy.loginfo("Goal #" + str(ur5.i-1) + " Sent")
            rospy.sleep(2)

    # Set, joints, angles definition for home position
    home_pos_list = [math.radians(7.838), math.radians(-139.943),
                     math.radians(-58.278), math.radians(-71.819),
                     math.radians(89.975), math.radians(7.833)]

    ur5.hard_set_joint_angles(home_pos_list, 5)

    while not rospy.is_shutdown():
        package_name = ur5.pkg_name
        try:
            # Condition check; if package detected is red
            if ur5.pick_condition == 1 and ic.dictorder[package_name] == "red":
                ur5.start_or_stop_conveyor(0)
                ur5.hard_set_joint_angles(home_pos_list, 5)
                # Attach package
                attach_flag_red = ur5.attach_or_detach_to_vg(True)
                if attach_flag_red:
                    rospy.logwarn("1. Playing Home to Red bin Trajectory File")
                    # Path from home pose to bin
                    ur5.moveit_hard_play_planned_path_from_file(ur5._file_path, 'home_to_red_bin_ur5_2.yaml', 5)
                    ur5.attach_or_detach_to_vg(False)
                    ur5.start_or_stop_conveyor(100)

                    mesg = json.dumps(ur5.lst_red[0])
                    goal_handle = ur5.action_client.send_goal("mqtt", "pub_ship", ur5.action_client._config_mqtt_pub_topic, mesg)    # sending message to bridge server
                    # updating goal handle
                    ur5.action_client._goal_handles[ur5.i] = goal_handle
                    ur5.i += 1
                    rospy.loginfo("Goal #" + str(ur5.i-1) + " Sent")
                    ur5.lst_red.pop(0)
                    rospy.logwarn("2. Playing Red bin to Home Trajectory File")
                    ur5.moveit_hard_play_planned_path_from_file(ur5._file_path, 'red_bin_to_home_ur5_2.yaml', 5)  # Path from bin to home pose
                    attach_flag_red = 0

            # Condition check; if package detected is green
            if ur5.pick_condition == 1 and ic.dictorder[package_name] == "green":
                ur5.start_or_stop_conveyor(0)
                ur5.hard_set_joint_angles(home_pos_list, 5)
                # Attach package
                attach_flag_green = ur5.attach_or_detach_to_vg(True)
                if attach_flag_green:
                    rospy.logwarn("5. Playing Home to Green bin Trajectory File")
                    # Path from home pose to bin
                    ur5.moveit_hard_play_planned_path_from_file(ur5._file_path, 'home_to_green_bin_ur5_2.yaml', 5)
                    ur5.attach_or_detach_to_vg(False)
                    ur5.start_or_stop_conveyor(100)

                    mesg = json.dumps(ur5.lst_green[0])
                    goal_handle = ur5.action_client.send_goal("mqtt", "pub_ship", ur5.action_client._config_mqtt_pub_topic, mesg)    # sending message to bridge server
                    # updating goal handle
                    ur5.action_client._goal_handles[ur5.i] = goal_handle
                    ur5.i += 1
                    rospy.loginfo("Goal #" + str(ur5.i-1) + " Sent")
                    ur5.lst_green.pop(0)
                    rospy.logwarn("6. Playing Green Bin to Home Trajectory File")
                    ur5.moveit_hard_play_planned_path_from_file(ur5._file_path, 'green_bin_to_home_ur5_2.yaml', 5)  # Path from bin to home pose
                    attach_flag_green = 0

            # Condition check; if package detected is yellow
            if ur5.pick_condition == 1 and ic.dictorder[package_name] == "yellow":
                ur5.start_or_stop_conveyor(0)
                ur5.hard_set_joint_angles(home_pos_list, 5)
                # Attach package
                attach_flag_yellow = ur5.attach_or_detach_to_vg(True)
                if attach_flag_yellow:
                    rospy.logwarn("3. Playing Home to Yellow bin Trajectory File")
                    ur5.moveit_hard_play_planned_path_from_file(ur5._file_path, 'home_to_yellow_bin_ur5_2.yaml', 5)  # Path from home pose to bin
                    ur5.attach_or_detach_to_vg(False)
                    ur5.start_or_stop_conveyor(100)

                    mesg = json.dumps(ur5.lst_yellow[0])
                    goal_handle = ur5.action_client.send_goal("mqtt", "pub_ship", ur5.action_client._config_mqtt_pub_topic, mesg)    # sending message to bridge server
                    # updating goal handle
                    ur5.action_client._goal_handles[ur5.i] = goal_handle
                    ur5.i += 1
                    rospy.loginfo("Goal #" + str(ur5.i-1) + " Sent")
                    ur5.lst_yellow.pop(0)
                    rospy.logwarn("4. Playing Yellow bin to home Trajectory File")
                    ur5.moveit_hard_play_planned_path_from_file(ur5._file_path, 'yellow_bin_to_home_ur5_2.yaml', 5)  # Path from bin to home pose
                    attach_flag_yellow = 0

        except:
            pass

    del ur5


if __name__ == '__main__':
    main()

